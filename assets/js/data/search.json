[
  
  {
    "title": "OWASP Research Page",
    "url": "/practice1.github.io/posts/OWASPResearch1/",
    "categories": "Research",
    "tags": "cybersecurity, research, owasp",
    "date": "2023-08-13 16:55:00 +0400",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Natas Wargame Writeup (Levels 0-10)",
    "url": "/practice1.github.io/posts/nataslevel0to10/",
    "categories": "Blogging, Writeup",
    "tags": "blogging, cybersecurity, programming, wargame, natas",
    "date": "2023-08-07 16:57:00 +0400",
    





    
    "snippet": "IntroductionThis writeup demonstrates each level of the natas wargame and all solutions needed to solve each level alongside the password and possible real world fixes to prevent the exploiting of ...",
    "content": "IntroductionThis writeup demonstrates each level of the natas wargame and all solutions needed to solve each level alongside the password and possible real world fixes to prevent the exploiting of vulnerabilities.In this writeup I will present everything in levels 0 - 10. The code in each level will be posted at the start of the level section, followed by the level credentials, and the password at the bottom.If you haven’t already, check out the introduction to the wargame.Level 0URL: http://natas0.natas.labs.overthewire.orgClick me to see the Level Credentials!natas0:natas0Code&lt;html&gt;    &lt;body&gt;        &lt;h1&gt;          natas0        &lt;/h1&gt;        &lt;div id=\"content\"&gt;          You can find the password for the next level on this page.          &lt;!--The password for natas1 is g9D9cREhslqBKtcA2uocGHPfMZVzeFK6 --&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;SolutionIn the first level of the Natas Wargame, the solution to acquiring the password was simple. All that was necessary was to right click and inspect and view the source code, where the password was commented out.FixThe real world solution to a vulnerability such as this would be to store the sensitive information separately in a file that cannot be accessed by an attacker and can only be opened by the website that needs it.Password: g9D9cREhslqBKtcA2uocGHPfMZVzeFK6Level 1URL: http://natas1.natas.labs.overthewire.orgClick me to see the Level Credentials!natas1:g9D9cREhslqBKtcA2uocGHPfMZVzeFK6Code&lt;body oncontextmenu=\"javascript:alert('right clicking has been blocked!');return false;\"&gt;    &lt;h1&gt;      natas1    &lt;/h1&gt;    &lt;div id=\"content\"&gt;      You can find the password for the      next level on this page, but rightclicking has been blocked!        &lt;!--The password for natas2 is h4ubbcXrWqsTo7GGnnUMLppXbOogfBZ7 --&gt;    &lt;/div&gt;&lt;/body&gt;SolutionIn the second level, the solution was to, since right clicking was disabled, use the browser shortcut combination to inspect the page and read the source code. Since I used the Macintosh OS, I had to use CMD + OPT + I. (Ctrl+Shift+I for WIN OS) This level disabled right clicking, returning an alert saying that it was disabled whenever right clicking was attempted. Upon inspecting, I could see that the password was commented out via the &lt;!--  (comment)  --&gt; method.FixThe fix for a vulnerability like this should be almost identical to the solution proposed in Level 0, and to sum it up, it is to store sensitive information in a secure file. Moreover, disabling right click in the website may be detrimental towards the overall user experience which may drive users away from visiting the page as without right click, some other features may be disabled which makes it harder for the user.Password: h4ubbcXrWqsTo7GGnnUMLppXbOogfBZ7Level 2URL: http://natas2.natas.labs.overthewire.orgClick me to see the Level Credentials!natas2:h4ubbcXrWqsTo7GGnnUMLppXbOogfBZ7Code&lt;body&gt;  &lt;h1&gt;natas2&lt;/h1&gt;    &lt;div id=\"content\"&gt;      There is nothing on this page    &lt;img src=\"files/pixel.png\"&gt;  &lt;/div&gt;&lt;/body&gt;SolutionOn this level, there was a reference made to the page’s files. Upon inspecting the code, there was a pixel.png image. Upon clicking the link, I was redirected to /files/pixel.png. Then, having navigated to /files/, I found myself in the directory, where the password for this level was located in users.txt.FixThe solution for this problem would be to disable access to the /files directory for regular users and store the user credentials page in a much more secure environment.Password: G6ctbMJ5Nb4cbFwhpMPSvxGHhQ7I6W8QLevel 3URL: http://natas3.natas.labs.overthewire.orgClick me to see the Level Credentials!natas3:G6ctbMJ5Nb4cbFwhpMPSvxGHhQ7I6W8QCode&lt;body&gt;    &lt;h1&gt;      natas3    &lt;/h1&gt;    &lt;div id=\"content\"&gt;        There is nothing on this page        &lt;!-- No more information leaks!! Not even Google will find it this time... --&gt;    &lt;/div&gt;&lt;/body&gt;SolutionIn this level, the inspect of the page made a reference to the robots.txt file - ‘not even google (search engine -&gt; robots) will find it…’. When I visited the robots page, it showed that /s3cr3t was disallowed, so I changed the url to end with /s3cr3t and came across the users.txt file which contained the login and password for the next level.FixIn a real world scenario, the robots.txt file should never be exposed, as this would not only open up the vulnerability demonstrated here, it would also subject the site to possible attacks. The correct method to use would be to utilize .httaccess and disable all access to robots.txt.Password: tKOcJIbzM4lTs8hbCmzn5Zr4434fGZQmLevel 4URL: http://natas4.natas.labs.overthewire.orgClick me to see the Level Credentials!natas4:tKOcJIbzM4lTs8hbCmzn5Zr4434fGZQmCode&lt;body&gt;    &lt;h1&gt;      natas4    &lt;/h1&gt;    &lt;div id=\"content\"&gt;        Access disallowed. You are visiting from \"\" while authorized users should come only from \"http://natas5.natas.labs.overthewire.org/\"      &lt;br/&gt;      &lt;div id=\"viewsource\"&gt;        &lt;a href=\"index.php\"&gt;          Refresh page        &lt;/a&gt;      &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;SolutionLevel 4 showed on the page that the user had to come from the site/the referer had to be natas5.natas.labs.overthewire.org in order to be shown the password, or, the referer had to be changed to the desired url somehow. The method that I used for this was I used Burp Suite1to intercept the proxy request and manipulate it so that it now had a different referer. Having done this, the page returned the password.FixThis level demonstrated how attackers could manipulate referers to impersonate a legitimate user. In a real world scenario, checking the referer header as a means of security is an extremely poor choice. The solution would be to not use it as a means of authentication, rather to look towards a more practical means such as a login.Password: Z0NsrtIkJoKALBCLi5eqFfcRN82Au2oDLevel 5URL: http://natas5.natas.labs.overthewire.orgClick me to see the Level Credentials!natas5:Z0NsrtIkJoKALBCLi5eqFfcRN82Au2oDCode&lt;body&gt;    &lt;h1&gt;      natas5    &lt;/h1&gt;    &lt;div id=\"content\"&gt;        Access disallowed. You are not logged in    &lt;/div&gt;&lt;/body&gt;HeadersGET / HTTP/1.1Host: natas5.natas.labs.overthewire.orgCache-Control: max-age=0Authorization: Basic bmF0YXM1OlowTnNydElrSm9LQUxCQ0xpNWVxRmZjUk44MkF1Mm9EUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.110 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: loggedin=0Connection: close  The cookie in Headers are a key part of authentication in almost all web servers.SolutionLevel 5 consisted of a page that showed Access Denied, you are not logged in. Upon inspection, it could be seen that the login cookie was loggedin = 0. By utilizing Burp Suite to intercept the cookie and change it to 1, I was given the password.FixUsing cookies that are not encrypted, unsigned and easily edited is a problem because it allows for session hijacking and cookie manipulation attacks. The solution for this would be to use a hidden encryption method to encode the cookie ID and sign it to ensure that the cookie was not tampered and secure, possibly by signing it.Password: fOIvE0MDtPTgRhqmmvvAOt2EfXR6uQgRLevel 6URL: http://natas6.natas.labs.overthewire.orgClick me to see the Level Credentials!natas6:fOIvE0MDtPTgRhqmmvvAOt2EfXR6uQgRCode&lt;?include \"includes/secret.inc\";    if(array_key_exists(\"submit\", $_POST)) {        if($secret == $_POST['secret']) {        print \"Access granted. The password for natas7 is &lt;censored&gt;\";    } else {        print \"Wrong secret\";    }    }?&gt;SolutionWhen I viewed the source code in this level, there was a line that showed that the url must include includes/secret.inc. Upon changing the URL to include includes/secret.inc, I was rewarded with the secret, which I promptly entered into the original page revealing the password.FixThe easiest fix for this url vulnerability would be to disable direct access to the file using .httaccess and set it to deny for all. Another option would be to store the secret/sensitive information in a separate file located in a secure environment, which, in case of a breach, would still hide the info.Password: jmxSiH3SP6Sonf8dv66ng8v1cIEdjXWrLevel 7URL: http://natas7.natas.labs.overthewire.orgClick me to see the Level Credentials!natas7:jmxSiH3SP6Sonf8dv66ng8v1cIEdjXWrCode&lt;body&gt;&lt;h1&gt;natas7&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;a href=\"index.php?page=home\"&gt;Home&lt;/a&gt;&lt;a href=\"index.php?page=about\"&gt;About&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 --&gt;&lt;/div&gt;&lt;/body&gt;SolutionThis page showed a home page. After inspecting the page, I found a hint that said that the password was in /etc/natas_webpass/natas8, so I changed the url to include it to perform a local file inclusion attack, which returned the password.FixLocal File Inclusion is extremely dangerous to the host as it can lead to cross site scripting giving attackers full control of the website. To prevent LFI, proper filtering with a whitelist should be used as well as storing sensitive information within a database. Another solution for this would be to disable direct access to files containing sensitive info in the database, this can be done by removing the includes folder from the web root and adding a .httaccess deny for all file which denies all direct access to the sensitive information.Password: a6bZCNYwdKqN5cGP11ZdtPg0iImQQhABLevel 8URL: http://natas8.natas.labs.overthewire.orgClick me to see the Level Credentials!natas8:a6bZCNYwdKqN5cGP11ZdtPg0iImQQhABCode&lt;?$encodedSecret = \"3d3d516343746d4d6d6c315669563362\";function encodeSecret($secret) {    return bin2hex(strrev(base64_encode($secret)));}if(array_key_exists(\"submit\", $_POST)) {    if(encodeSecret($_POST['secret']) == $encodedSecret) {    print \"Access granted. The password for natas9 is &lt;censored&gt;\";    } else {    print \"Wrong secret\";    }}?&gt;SolutionLevel 8 consists of a form asking for a secret to be input and a link to its source code. Upon inspecting the source code, I could see that the secret was encoded through base64, string reversal and hexcode. I created a separate program and ran the reverse functions and inputted the encoded secret and was returned the original secret, which I entered in the box, showing the password.FixThe solution to this would be to store the encryption method in a hidden file so that it would be much harder to decrypt the string and to hide the encrypted string and plaintext.Password: Sda6t0vkOPkM8YeOZkAGVhFoaplvlJFdLevel 9URL: http://natas9.natas.labs.overthewire.orgClick me to see the Level Credentials!natas9:Sda6t0vkOPkM8YeOZkAGVhFoaplvlJFdCode&lt;?$key = \"\";if(array_key_exists(\"needle\", $_REQUEST)) {    $key = $_REQUEST[\"needle\"];}if($key != \"\") {    passthru(\"grep -i $key dictionary.txt\");}?&gt;SolutionThis level involved a dictionary, where the password was hidden inside of it. It involved a query of X /etc/natas_webpass/natas10, which upon entered, revealed the password. The query that I submitted was c /etc/natas_webpass/natas10, due to the password itself containing a c. This was done after trial and error. Having looked into the level further, I found that the program returned everything that contained the key strings and characters.FixThe solution to this would be to store the password in a separate file that can’t be accessed. Alternatively, code could be added disabling the usage of all special characters, converting it all to string and disabling input of sensitive url sections for example, in this particular scenario, ‘natas_webpass’.Password: D44EcsFkLxPIkAAKLosx8z3hxX1Z4MCELevel 10URL: http://natas10.natas.labs.overthewire.orgClick me to see the Level Credentials!natas10:D44EcsFkLxPIkAAKLosx8z3hxX1Z4MCECode&lt;?$key = \"\";if(array_key_exists(\"needle\", $_REQUEST)) {    $key = $_REQUEST[\"needle\"];}if($key != \"\") {    if(preg_match('/[;|&amp;]/',$key)) {        print \"Input contains an illegal character!\";    } else {        passthru(\"grep -i $key dictionary.txt\");    }}?&gt;SolutionThis level was the same except it didn’t allow the input for any ‘special’ characters. My solution for this involved using “”, which tricked the system into showing the password. What I typed out was “” /etc/natas_webpass/natas11. This ended up returning everything within dictionary.txt, including the credentials for the next level.FixThe solution to this would be the same as the previous level - store the password in a separate file that can’t be accessed. Alternatively, code could be added disabling the usage of all special characters, converting it all to string and disabling input of sensitive url sections such as ‘natas_webpass’.Password: 1KFqoJXi6hRaPluAmk8ESDW4fSysRoIgWhat’s Next?If you are interested in reading about the next 10 levels, click here.Additional Footnotes            Burp Suite is a usable tool that helps exploit website vulnerabilities which developers and ethical hackers can use to learn about and improve security. I chose to use this application, however there are also other similarly functioning programs such as Hydra. &#8617;      "
  },
  
  {
    "title": "Natas Wargame Writeup (Levels 11-20)",
    "url": "/practice1.github.io/posts/nataslevel11-20/",
    "categories": "Blogging, Writeup",
    "tags": "blogging, cybersecurity, programming, wargame, natas",
    "date": "2023-08-07 16:56:00 +0400",
    





    
    "snippet": "IntroductionThis blog post contains the writeup for the natas wargame levels 11 to 20.If you haven’t already, I recommend reading the previous articles on the introduction and the writeup on Levels...",
    "content": "IntroductionThis blog post contains the writeup for the natas wargame levels 11 to 20.If you haven’t already, I recommend reading the previous articles on the introduction and the writeup on Levels 0-10.Level 11URL: http://natas11.natas.labs.overthewire.orgCredentials: natas11:1KFqoJXi6hRaPluAmk8ESDW4fSysRoIgCode&lt;?$defaultdata = array( \"showpassword\"=&gt;\"no\", \"bgcolor\"=&gt;\"#ffffff\");function xor_encrypt($in) {    $key = '&lt;censored&gt;';    $text = $in;    $outText = '';    // Iterate through each character    for($i=0;$i&lt;strlen($text);$i++) {    $outText .= $text[$i] ^ $key[$i % strlen($key)];    }    return $outText;}function loadData($def) {    global $_COOKIE;    $mydata = $def;    if(array_key_exists(\"data\", $_COOKIE)) {    $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[\"data\"])), true);    if(is_array($tempdata) &amp;&amp; array_key_exists(\"showpassword\", $tempdata) &amp;&amp; array_key_exists(\"bgcolor\", $tempdata)) {        if (preg_match('/^#(?:[a-f\\d]{6})$/i', $tempdata['bgcolor'])) {        $mydata['showpassword'] = $tempdata['showpassword'];        $mydata['bgcolor'] = $tempdata['bgcolor'];        }    }    }    return $mydata;}function saveData($d) {    setcookie(\"data\", base64_encode(xor_encrypt(json_encode($d))));}$data = loadData($defaultdata);if(array_key_exists(\"bgcolor\",$_REQUEST)) {    if (preg_match('/^#(?:[a-f\\d]{6})$/i', $_REQUEST['bgcolor'])) {        $data['bgcolor'] = $_REQUEST['bgcolor'];    }}saveData($data);?&gt;&lt;h1&gt;natas11&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;body style=\"background: &lt;?=$data['bgcolor']?&gt;;\"&gt;Cookies are protected with XOR encryption&lt;br/&gt;&lt;br/&gt;&lt;?if($data[\"showpassword\"] == \"yes\") {    print \"The password for natas12 is &lt;censored&gt;&lt;br&gt;\";}?&gt;&lt;form&gt;Background color: &lt;input name=bgcolor value=\"&lt;?=$data['bgcolor']?&gt;\"&gt;&lt;input type=submit value=\"Set color\"&gt;&lt;/form&gt;SolutionUpon inspecting the source code, I saw that Level 11 involved XOR encryption. The method I used to tackle this was to reverse engineer the encryption to find the key used in the encryption, then once the key was obtained, I reencrypted the edited plaintext with the value of show password being yes. A problem that I came across was in using multiple programs to encode the edited plaintext. This was due to invisible characters failing to be displayed, which resulted in error.FixThe solution to this would be to hide the plaintext in a separate secure file which would disable this method. Alternatively, it would be possible to use generate a completely random string and store it in an external file, making it virtually impossible for the attacker to gain another code.Password: YWqo0pjpcXzSIl5NMAVxg12QxeC1w9QGLevel 12URL: http://natas12.natas.labs.overthewire.orgCredentials: natas12:YWqo0pjpcXzSIl5NMAVxg12QxeC1w9QGCode&lt;?phpfunction genRandomString() {    $length = 10;    $characters = \"0123456789abcdefghijklmnopqrstuvwxyz\";    $string = \"\";    for ($p = 0; $p &lt; $length; $p++) {        $string .= $characters[mt_rand(0, strlen($characters)-1)];    }    return $string;}function makeRandomPath($dir, $ext) {    do {    $path = $dir.\"/\".genRandomString().\".\".$ext;    } while(file_exists($path));    return $path;}function makeRandomPathFromFilename($dir, $fn) {    $ext = pathinfo($fn, PATHINFO_EXTENSION);    return makeRandomPath($dir, $ext);}if(array_key_exists(\"filename\", $_POST)) {    $target_path = makeRandomPathFromFilename(\"upload\", $_POST[\"filename\"]);        if(filesize($_FILES['uploadedfile']['tmp_name']) &gt; 1000) {        echo \"File is too big\";    } else {        if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) {            echo \"The file &lt;a href=\\\"$target_path\\\"&gt;$target_path&lt;/a&gt; has been uploaded\";        } else{            echo \"There was an error uploading the file, please try again!\";        }    }} else {?&gt;&lt;form enctype=\"multipart/form-data\" action=\"index.php\" method=\"POST\"&gt;&lt;input type=\"hidden\" name=\"MAX_FILE_SIZE\" value=\"1000\" /&gt;&lt;input type=\"hidden\" name=\"filename\" value=\"&lt;?php print genRandomString(); ?&gt;.jpg\" /&gt;Choose a JPEG to upload (max 1KB):&lt;br/&gt;&lt;input name=\"uploadedfile\" type=\"file\" /&gt;&lt;br /&gt;&lt;input type=\"submit\" value=\"Upload File\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;SolutionLevel 12 was composed of a file uploader which asked for images to be uploaded, then it would store the file in its directory. To pass this level, I intercepted the request transmitted using Burp Suite, then I changed the contents of the jpeg to a webshell which would allow me to execute commands. I also changed the file type to php, so that it would be compatible with the webshell. Upon forwarding, I changed the URL to from /index.php to /index.php?cmd=cat/etc/natas_webpass/natas13. This line concatenated the contents of the file, which was the password.FixThe fix for vulnerabilities with uploading files would be to check the file type against whitelisted file extensions, and have a proper validation system. It would also help to ensure that all contents were converted to plaintext.Password: lW3jYRI02ZKDBb8VtQBU1f6eDRo6WEj9Level 13URL: http://natas13.natas.labs.overthewire.orgCredentials: natas13:lW3jYRI02ZKDBb8VtQBU1f6eDRo6WEj9Code&lt;?phpfunction genRandomString() {    $length = 10;    $characters = \"0123456789abcdefghijklmnopqrstuvwxyz\";    $string = \"\";    for ($p = 0; $p &lt; $length; $p++) {        $string .= $characters[mt_rand(0, strlen($characters)-1)];    }    return $string;}function makeRandomPath($dir, $ext) {    do {    $path = $dir.\"/\".genRandomString().\".\".$ext;    } while(file_exists($path));    return $path;}function makeRandomPathFromFilename($dir, $fn) {    $ext = pathinfo($fn, PATHINFO_EXTENSION);    return makeRandomPath($dir, $ext);}if(array_key_exists(\"filename\", $_POST)) {    $target_path = makeRandomPathFromFilename(\"upload\", $_POST[\"filename\"]);    $err=$_FILES['uploadedfile']['error'];    if($err){        if($err === 2){            echo \"The uploaded file exceeds MAX_FILE_SIZE\";        } else{            echo \"Something went wrong :/\";        }    } else if(filesize($_FILES['uploadedfile']['tmp_name']) &gt; 1000) {        echo \"File is too big\";    } else if (! exif_imagetype($_FILES['uploadedfile']['tmp_name'])) {        echo \"File is not an image\";    } else {        if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) {            echo \"The file &lt;a href=\\\"$target_path\\\"&gt;$target_path&lt;/a&gt; has been uploaded\";        } else{            echo \"There was an error uploading the file, please try again!\";        }    }} else {?&gt;&lt;form enctype=\"multipart/form-data\" action=\"index.php\" method=\"POST\"&gt;&lt;input type=\"hidden\" name=\"MAX_FILE_SIZE\" value=\"1000\" /&gt;&lt;input type=\"hidden\" name=\"filename\" value=\"&lt;?php print genRandomString(); ?&gt;.jpg\" /&gt;Choose a JPEG to upload (max 1KB):&lt;br/&gt;&lt;input name=\"uploadedfile\" type=\"file\" /&gt;&lt;br /&gt;&lt;input type=\"submit\" value=\"Upload File\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;SolutionThis stage was almost identical to the previous stage, except it utilized ‘exif_imagetype’ to ensure the file uploaded was an image. Initially, I attempted to bypass it by using terminal to hide a php file within a jpeg, however it was too large as the program now only accepted files smaller than 1KB. Following this, I instead inserted the line GIF89a in the initial area of the code. What this did was that it tricked the program into thinking it was a gif file, which is a subcategory of images, which passed the exif_imagetype check. From here, I created the webshell as before using (replace %3F with ?), and edited the url as before which gave me the password.FixThe fix for this vulnerability is the same as the previous issue - check the type of file against whitelisted file extensions, and have a proper validation system, also possibly converting file contents to plaintext.Password: qPazSJBmrmU7UQJv17MHk1PGC4DxZMEPLevel 14URL: http://natas14.natas.labs.overthewire.orgCredentials: natas14:qPazSJBmrmU7UQJv17MHk1PGC4DxZMEPCode&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = { \"level\": \"natas14\", \"pass\": \"&lt;censored&gt;\" };&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas14&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;?phpif(array_key_exists(\"username\", $_REQUEST)) {    $link = mysqli_connect('localhost', 'natas14', '&lt;censored&gt;');    mysqli_select_db($link, 'natas14');    $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\" and password=\\\"\".$_REQUEST[\"password\"].\"\\\"\";    if(array_key_exists(\"debug\", $_GET)) {        echo \"Executing query: $query&lt;br&gt;\";    }    if(mysqli_num_rows(mysqli_query($link, $query)) &gt; 0) {            echo \"Successful login! The password for natas15 is &lt;censored&gt;&lt;br&gt;\";    } else {            echo \"Access denied!&lt;br&gt;\";    }    mysqli_close($link);} else {?&gt;&lt;form action=\"index.php\" method=\"POST\"&gt;Username: &lt;input name=\"username\"&gt;&lt;br&gt;Password: &lt;input name=\"password\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"Login\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 14 looks relatively simple - a $_POST request indicating the entry of a username and password into the form. Since guessing the password and username would be almost impossible and brute forcing was not an option, I therefore used an SQL injection as I found that there was usage of mysql in the source code. I wrote ‘’ or “”=“ in place of the password, which meant that the statement provided guaranteed a return true, manipulating the code into thinking that the correct username and password was entered, thus it showed the password.FixThe solution to prevent sequel injections would be to stop writing dynamic queries with string concatenation and/or prevent user supplied input containing malicious SQL from affecting the logic of the query.Password: TTkaI7AWG4iDERztBcEyKV7kRXH1EZRBLevel 15URL: http://natas15.natas.labs.overthewire.orgCredentials: natas15:TTkaI7AWG4iDERztBcEyKV7kRXH1EZRBCode&lt;html&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = { \"level\": \"natas15\", \"pass\": \"&lt;censored&gt;\" };&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas15&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;?php/*CREATE TABLE `users` (  `username` varchar(64) DEFAULT NULL,  `password` varchar(64) DEFAULT NULL);*/if(array_key_exists(\"username\", $_REQUEST)) {    $link = mysqli_connect('localhost', 'natas15', '&lt;censored&gt;');    mysqli_select_db($link, 'natas15');    $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\";    if(array_key_exists(\"debug\", $_GET)) {        echo \"Executing query: $query&lt;br&gt;\";    }    $res = mysqli_query($link, $query);    if($res) {    if(mysqli_num_rows($res) &gt; 0) {        echo \"This user exists.&lt;br&gt;\";    } else {        echo \"This user doesn't exist.&lt;br&gt;\";    }    } else {        echo \"Error in query.&lt;br&gt;\";    }    mysqli_close($link);} else {?&gt;&lt;form action=\"index.php\" method=\"POST\"&gt;Username: &lt;input name=\"username\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"Check existence\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionThis level only had a username box, and it only verified if the user existed. Upon inspecting the code, it could be noted that there was a vulnerability to Blind SQL injection, where I would have to add another condition such as ‘1=1’ to create a true false statement regarding the password. http://natas15.natas.labs.overthewire.org/index.php?username=natas16%22%20and%20ord(mid(password,1,1))%3E97%20and%20%221%22=%221 This line shows how it would be done to check the 1st char of the password. The data tables were shown in the source code, and the username was already known.FixThe fix for a vulnerability to blind sql injection would be to use parametrized queries that would ensure that the user would be unable to interfere with the SQL query.Password: TRD7iZrd5gATjj9PkPEuaOlfEjHqj32VLevel 16URL: http://natas16.natas.labs.overthewire.orgCredentials: natas16:TRD7iZrd5gATjj9PkPEuaOlfEjHqj32VCode&lt;html&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = { \"level\": \"natas16\", \"pass\": \"&lt;censored&gt;\" };&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas16&lt;/h1&gt;&lt;div id=\"content\"&gt;For security reasons, we now filter even more on certain characters&lt;br/&gt;&lt;br/&gt;&lt;form&gt;Find words containing: &lt;input name=needle&gt;&lt;input type=submit name=submit value=Search&gt;&lt;br&gt;&lt;br&gt;&lt;/form&gt;Output:&lt;pre&gt;&lt;?$key = \"\";if(array_key_exists(\"needle\", $_REQUEST)) {    $key = $_REQUEST[\"needle\"];}if($key != \"\") {    if(preg_match('/[;|&amp;`\\'\"]/',$key)) {        print \"Input contains an illegal character!\";    } else {        passthru(\"grep -i \\\"$key\\\" dictionary.txt\");    }}?&gt;&lt;/pre&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionThis level bore resemblance to level 10, however the difference was that it had filtered out the double quotes as well as everything else. This was a problem because it forced a different solution. To get to the password, I utilized the grep function in the url of the page. by inserting KEYWORD$(grep char /etc/natas_webpass/natas17), I was able to determine which characters were in the password by running a line of code which returned the character and concatenated it to a string when the keyword didn’t appear. To find out what order they were in, I used the ^ in front of the char string. By doing this with the list of filtered out characters, I was able to determine what character started the password and which ones succeeded it.FixThe fix for this vulnerability would be to incorporate a whitelist that only allows the input and returns characters, which disables the usage of characters such as () or / which are essential in this attack.Password: XkEuChE0SbnKBvH1RU7ksIb9uuLmI7sdLevel 17URL: http://natas 17.natas.labs.overthewire.orgCredentials: natas17:XkEuChE0SbnKBvH1RU7ksIb9uuLmI7sdCode&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;h1&gt;natas17&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;?php/*CREATE TABLE `users` (  `username` varchar(64) DEFAULT NULL,  `password` varchar(64) DEFAULT NULL);*/if(array_key_exists(\"username\", $_REQUEST)) {    $link = mysqli_connect('localhost', 'natas17', '&lt;censored&gt;');    mysqli_select_db($link, 'natas17');    $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\";    if(array_key_exists(\"debug\", $_GET)) {        echo \"Executing query: $query&lt;br&gt;\";    }    $res = mysqli_query($link, $query);    if($res) {    if(mysqli_num_rows($res) &gt; 0) {        //echo \"This user exists.&lt;br&gt;\";    } else {        //echo \"This user doesn't exist.&lt;br&gt;\";    }    } else {        //echo \"Error in query.&lt;br&gt;\";    }    mysqli_close($link);} else {?&gt;&lt;form action=\"index.php\" method=\"POST\"&gt;Username: &lt;input name=\"username\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"Check existence\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionIn this level, it was clear that the level had SQL vulnerabilities because of the page’s usage of mysql. Looking at the code, there was nothing that would support boolean based blind sql injection, so I resorted to a time based sql injection method by using SQLmap. Then method worked by inserting the time delay condition which would be activated and noticed if the other condition was fulfilled, which was if the characters were in the password. It required me to provide authentication and table information to the sqlmap, and it did the rest of the work, giving me the password. SQLMap simply performs sql injections automatically at mechanical precision, which make it a lot more time saving especially for time based SQL injections.FixThe solution to prevent sequel injections would be to stop writing dynamic queries with string concatenation and/or prevent user supplied input containing malicious SQL from affecting the logic of the query.Password: 8NEDUUxg8kFgPV84uLwvZkGn6okJQ6aqLevel 18URL: http://natas18.natas.labs.overthewire.orgCredentials: natas18:8NEDUUxg8kFgPV84uLwvZkGn6okJQ6aqCode&lt;html&gt;&lt;body&gt;&lt;h1&gt;natas18&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;?php$maxid = 640; // 640 should be enough for everyonefunction isValidAdminLogin() {     if($_REQUEST[\"username\"] == \"admin\") {    /* This method of authentication appears to be unsafe and has been disabled for now. */        //return 1;    }    return 0;}function isValidID($id) {     return is_numeric($id);}function createID($user) {     global $maxid;    return rand(1, $maxid);}function debug($msg) {     if(array_key_exists(\"debug\", $_GET)) {        print \"DEBUG: $msg&lt;br&gt;\";    }}function my_session_start() {     if(array_key_exists(\"PHPSESSID\", $_COOKIE) and isValidID($_COOKIE[\"PHPSESSID\"])) {    if(!session_start()) {        debug(\"Session start failed\");        return false;    } else {        debug(\"Session start ok\");        if(!array_key_exists(\"admin\", $_SESSION)) {        debug(\"Session was old: admin flag set\");        $_SESSION[\"admin\"] = 0; // backwards compatible, secure        }        return true;    }    }    return false;}function print_credentials() {     if($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1) {    print \"You are an admin. The credentials for the next level are:&lt;br&gt;\";    print \"&lt;pre&gt;Username: natas19\\n\";    print \"Password: &lt;censored&gt;&lt;/pre&gt;\";    } else {    print \"You are logged in as a regular user. Login as an admin to retrieve credentials for natas19.\";    }}$showform = true;if(my_session_start()) {    print_credentials();    $showform = false;} else {    if(array_key_exists(\"username\", $_REQUEST) &amp;&amp; array_key_exists(\"password\", $_REQUEST)) {    session_id(createID($_REQUEST[\"username\"]));    session_start();    $_SESSION[\"admin\"] = isValidAdminLogin();    debug(\"New session started\");    $showform = false;    print_credentials();    }}if($showform) {?&gt;&lt;p&gt;Please login with your admin account to retrieve credentials for natas19.&lt;/p&gt;&lt;form action=\"index.php\" method=\"POST\"&gt;Username: &lt;input name=\"username\"&gt;&lt;br&gt;Password: &lt;input name=\"password\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"Login\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionThis level required cookie manipulation. It would be known that the user would be admin and the password was unknown, however by using Burp Suite and running through the first 640 possible cookie ids (640 was the maximum id of a cookie), I found one irregularity and replaced my cookie with that id and was given the password.FixThe solution for this would be to use a randomly generated encryption method in place of the cookie and store the data in a secure file to ensure that it would be near impossible to recreate the cookie. The cookie should also be signed to prevent client sided cookie manipulation improving the server security and decreasing the risk of a cookie hijacking attack.Password: 8LMJEhKFbMKIL2mxQKjv0aEDdk7zpT0sLevel 19URL: http://natas19.natas.labs.overthewire.orgClick me for the Level Credentials!Credentials: `natas19:8LMJEhKFbMKIL2mxQKjv0aEDdk7zpT0s`Code&lt;html&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = { \"level\": \"natas19\", \"pass\": \"&lt;censored&gt;\" };&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas19&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;p&gt;&lt;b&gt;This page uses mostly the same code as the previous level, but session IDs are no longer sequential...&lt;/b&gt;&lt;/p&gt;&lt;?php$maxid = 640; // 640 should be enough for everyonefunction myhex2bin($h) {   if (!is_string($h)) return null;  $r='';  for ($a=0; $a&lt;strlen($h); $a+=2) { $r.=chr(hexdec($h[$a].$h[($a+1)])); }  return $r;}function isValidAdminLogin() {     if($_REQUEST[\"username\"] == \"admin\") {    /* This method of authentication appears to be unsafe and has been disabled for now. */        //return 1;    }    return 0;}function isValidID($id) {     // must be lowercase    if($id != strtolower($id)) {        return false;    }    // must decode    $decoded = myhex2bin($id);    // must contain a number and a username    if(preg_match('/^(?P&lt;id&gt;\\d+)-(?P&lt;name&gt;\\w+)$/', $decoded, $matches)) {        return true;    }    return false;}function createID($user) {     global $maxid;    $idnum = rand(1, $maxid);    $idstr = \"$idnum-$user\";    return bin2hex($idstr);}function debug($msg) {     if(array_key_exists(\"debug\", $_GET)) {        print \"DEBUG: $msg&lt;br&gt;\";    }}function my_session_start() {     if(array_key_exists(\"PHPSESSID\", $_COOKIE) and isValidID($_COOKIE[\"PHPSESSID\"])) {    if(!session_start()) {        debug(\"Session start failed\");        return false;    } else {        debug(\"Session start ok\");        if(!array_key_exists(\"admin\", $_SESSION)) {        debug(\"Session was old: admin flag set\");        $_SESSION[\"admin\"] = 0; // backwards compatible, secure        }        return true;    }    }    return false;}function print_credentials() {     if($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1) {    print \"You are an admin. The credentials for the next level are:&lt;br&gt;\";    print \"&lt;pre&gt;Username: natas20\\n\";    print \"Password: &lt;censored&gt;&lt;/pre&gt;\";    } else {    print \"You are logged in as a regular user. Login as an admin to retrieve credentials for natas20.\";    }}$showform = true;if(my_session_start()) {    print_credentials();    $showform = false;} else {    if(array_key_exists(\"username\", $_REQUEST) &amp;&amp; array_key_exists(\"password\", $_REQUEST)) {    session_id(createID($_REQUEST[\"username\"]));    session_start();    $_SESSION[\"admin\"] = isValidAdminLogin();    debug(\"New session started\");    $showform = false;    print_credentials();    }}if($showform) {?&gt;&lt;p&gt;Please login with your admin account to retrieve credentials for natas20.&lt;/p&gt;&lt;form action=\"index.php\" method=\"POST\"&gt;Username: &lt;input name=\"username\"&gt;&lt;br&gt;Password: &lt;input name=\"password\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"Login\" /&gt;&lt;/form&gt;&lt;?php } ?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 19 was the same as level 18, however this time the session codes were formatted differently. I could see that it was hex code, and after entering the username, I found that the format was [ID-USERNAME]. Having found this out, I ran a script that converted numbers 1-640 to hex code and appended ‘2d61646d696ea’ to the end of the encoded values and ran a sniper attack cycling through the payloads until I was returned the password.FixThe quick solution for this would be to sign each individual cookie to ensure that the attacker cannot change the cookie id and conduct an attack because signing a cookie detects if the cookie has been tampered with.Password: guVaZ3ET35LbgbFMoaN5tFcYT1jEP7UHLevel 20URL: http://natas20.natas.labs.overthewire.orgCredentials: natas20:guVaZ3ET35LbgbFMoaN5tFcYT1jEP7UHCode&lt;html&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = { \"level\": \"natas20\", \"pass\": \"&lt;censored&gt;\" };&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;natas20&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;?phpfunction debug($msg) {     if(array_key_exists(\"debug\", $_GET)) {        print \"DEBUG: $msg&lt;br&gt;\";    }}function print_credentials() {     if($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1) {    print \"You are an admin. The credentials for the next level are:&lt;br&gt;\";    print \"&lt;pre&gt;Username: natas21\\n\";    print \"Password: &lt;censored&gt;&lt;/pre&gt;\";    } else {    print \"You are logged in as a regular user. Login as an admin to retrieve credentials for natas21.\";    }}/* we don't need this */function myopen($path, $name) {    //debug(\"MYOPEN $path $name\");    return true;}/* we don't need this */function myclose() {    //debug(\"MYCLOSE\");    return true;}function myread($sid) {    debug(\"MYREAD $sid\");    if(strspn($sid, \"1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM-\") != strlen($sid)) {    debug(\"Invalid SID\");        return \"\";    }    $filename = session_save_path() . \"/\" . \"mysess_\" . $sid;    if(!file_exists($filename)) {        debug(\"Session file doesn't exist\");        return \"\";    }    debug(\"Reading from \". $filename);    $data = file_get_contents($filename);    $_SESSION = array();    foreach(explode(\"\\n\", $data) as $line) {        debug(\"Read [$line]\");    $parts = explode(\" \", $line, 2);    if($parts[0] != \"\") $_SESSION[$parts[0]] = $parts[1];    }    return session_encode();}function mywrite($sid, $data) {    // $data contains the serialized version of $_SESSION    // but our encoding is better    debug(\"MYWRITE $sid $data\");    // make sure the sid is alnum only!!    if(strspn($sid, \"1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM-\") != strlen($sid)) {    debug(\"Invalid SID\");        return;    }    $filename = session_save_path() . \"/\" . \"mysess_\" . $sid;    $data = \"\";    debug(\"Saving in \". $filename);    ksort($_SESSION);    foreach($_SESSION as $key =&gt; $value) {        debug(\"$key =&gt; $value\");        $data .= \"$key $value\\n\";    }    file_put_contents($filename, $data);    chmod($filename, 0600);}/* we don't need this */function mydestroy($sid) {    //debug(\"MYDESTROY $sid\");    return true;}/* we don't need this */function mygarbage($t) {    //debug(\"MYGARBAGE $t\");    return true;}session_set_save_handler(    \"myopen\",    \"myclose\",    \"myread\",    \"mywrite\",    \"mydestroy\",    \"mygarbage\");session_start();if(array_key_exists(\"name\", $_REQUEST)) {    $_SESSION[\"name\"] = $_REQUEST[\"name\"];    debug(\"Name set to \" . $_REQUEST[\"name\"]);}print_credentials();$name = \"\";if(array_key_exists(\"name\", $_SESSION)) {    $name = $_SESSION[\"name\"];}?&gt;&lt;form action=\"index.php\" method=\"POST\"&gt;Your name: &lt;input name=\"name\" value=\"&lt;?=$name?&gt;\"&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"Change name\" /&gt;&lt;/form&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 20 contained of a password box asking for a name. Looking at the source code, I could see that the conditions needed for the password to be revealed was that the session had to contain the string ‘admin’ and the value admin had to be set as 1. To do this, I ran a python script that, after authenticating its connection to the server, it would submit ‘name=admin\\nadmin 1’. What this did was that it set the name to admin and the ‘\\n’ caused a line break, saving the string ‘admin 1’ on the following line. The reason that it was written as ‘admin 1’ and not admin=1 is because of how the file would store the session data.FixThe solution for this would be to only save the first line of input and use readline(1) to only account for the first line and ignore the rest of the response provided by the user.Password: 89OWrTkGmiLZLv12JY4tLj2c4FW0xn56What’s Next?If you are interested in reading about the next 5 levels, click here."
  },
  
  {
    "title": "Introduction to Natas Wargame",
    "url": "/practice1.github.io/posts/getting-started/",
    "categories": "Blogging, Introduction",
    "tags": "introduction",
    "date": "2023-08-07 16:55:00 +0400",
    





    
    "snippet": "What is the Natas Wargame?Natas teaches the basics of serverside cybersecurity through practical application in a ‘capture the flag’ style game, and the player, or attacker, learns how to certain m...",
    "content": "What is the Natas Wargame?Natas teaches the basics of serverside cybersecurity through practical application in a ‘capture the flag’ style game, and the player, or attacker, learns how to certain mechanics of web security are used and possible vulnerabilities.How Does the Wargame work?Each level of natas consists of its own website located at http://natasX.natas.labs.overthewire.org, where X is the level number. There is no SSH login. To access a level, you enter the username for that level (e.g. natas0 for level 0) and its password. Each level has access to the password of the next level. The objective is to somehow obtain that next password and level up, and there are no restrictions to what you can do to infiltrate the webpage to obtain the password through bypassing security measures.Link to wargame: overthewire.org/wargames/natasLevels (0-10)Levels (11-20)Levels (21-25)"
  },
  
  {
    "title": "Natas Wargame Writeup (Levels 21-25)",
    "url": "/practice1.github.io/posts/nataslevel21-25/",
    "categories": "Blogging, Writeup",
    "tags": "blogging, cybersecurity, programming, wargame, natas",
    "date": "2023-08-07 16:55:00 +0400",
    





    
    "snippet": "IntroductionThis blog post contains the writeup for the natas wargame levels 21 to 25.If you haven’t already, I recommend reading the previous articles on the introduction and the writeups on Level...",
    "content": "IntroductionThis blog post contains the writeup for the natas wargame levels 21 to 25.If you haven’t already, I recommend reading the previous articles on the introduction and the writeups on Levels 0-10 and Levels 11-20.Level 21URL: http://natas21.natas.labs.overthewire.orgCredentials: natas21:89OWrTkGmiLZLv12JY4tLj2c4FW0xn56Code&lt;html&gt;&lt;body&gt;&lt;h1&gt;natas21&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;p&gt;&lt;b&gt;Note: this website is colocated with &lt;a href=\"http://natas21-experimenter.natas.labs.overthewire.org\"&gt;http://natas21-experimenter.natas.labs.overthewire.org&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;?phpfunction print_credentials() {     if($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1) {    print \"You are an admin. The credentials for the next level are:&lt;br&gt;\";    print \"&lt;pre&gt;Username: natas22\\n\";    print \"Password: &lt;censored&gt;&lt;/pre&gt;\";    } else {    print \"You are logged in as a regular user. Login as an admin to retrieve credentials for natas22.\";    }}session_start();print_credentials();?&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 21 had two pages that were colocated - this meant they would share the same cookie data. By intercepting the second vulnerable proxy with Burp suite, I came across the form where it would take in data. After adding the string ‘&amp;admin=1’ to the end of the form, I forwarded the request, saved the cookie and replaced the cookie on the original page with the saved cookie containing the ‘admin=1’. This returned the password and I moved on.FixThe solution for this would be to ensure that both webpages colocated with each other have tightened security to prevent the exploit of a vulnerability in one site leading to the other site also being exposed to attacks.Click Me to see the Password!91awVM9oDiUGm33JdzM7RVLBS8bz9n0sLevel 22URL: http://natas22.natas.labs.overthewire.orgCredentials: natas22:91awVM9oDiUGm33JdzM7RVLBS8bz9n0sCode&lt;?phpsession_start();if(array_key_exists(\"revelio\", $_GET)) {    // only admins can reveal the password    if(!($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1)) {    header(\"Location: /\");    }}?&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;natas22&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;?php    if(array_key_exists(\"revelio\", $_GET)) {    print \"You are an admin. The credentials for the next level are:&lt;br&gt;\";    print \"&lt;pre&gt;Username: natas23\\n\";    print \"Password: &lt;censored&gt;&lt;/pre&gt;\";    }?&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 22 was a blank page and only had a hyperlink showing the source code. Upon looking at the code, I found the the header of the page had to contain the string ‘revelio’ in order to return the password. Following this, I opened BurpSuite and changed the URL to ‘http://natas22.natas.labs.overthewire.org/?revelio’ which returned the password.FixThe fix for this vulnerability would be to deny all access to the sensitive file from the .httaccess file. This would prevent the attacker from directly viewing the sensitive information.Password: qjA8cOoKFTzJhtV0Fzvt92fgvxVnVRBjLevel 23URL: http://natas23.natas.labs.overthewire.orgCredentials: natas23:qjA8cOoKFTzJhtV0Fzvt92fgvxVnVRBjCode&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;h1&gt;natas23&lt;/h1&gt;&lt;div id=\"content\"&gt;Password:&lt;form name=\"input\" method=\"get\"&gt;    &lt;input type=\"text\" name=\"passwd\" size=20&gt;    &lt;input type=\"submit\" value=\"Login\"&gt;&lt;/form&gt;&lt;?php    if(array_key_exists(\"passwd\",$_REQUEST)){        if(strstr($_REQUEST[\"passwd\"],\"iloveyou\") &amp;&amp; ($_REQUEST[\"passwd\"] &gt; 10 )){            echo \"&lt;br&gt;The credentials for the next level are:&lt;br&gt;\";            echo \"&lt;pre&gt;Username: natas24 Password: &lt;censored&gt;&lt;/pre&gt;\";        }        else{            echo \"&lt;br&gt;Wrong!&lt;br&gt;\";        }    }?&gt;  &lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 23 consisted of a password box and a submit button. Upon looking at the code, I found that the password, or var passwd, had to contain ‘iloveyou’ and have a numerical value greater than 20. Following this, I entered the string ‘iloveyou100’ as the password which returned false. Changing it to ‘100iloveyou’, I was given the password. Turns out that this was because the wargame ran on php 7, therefore it took in the first numerical value and ignored the second.FixThe fix for this would be to have a much more secure password that is hidden elsewhere so that the attacker cannot easily identify under what conditions a password is correct.Password: 0xzF30T9Av8lgXhW7slhFCIsVKAPyl2rLevel 24URL: http://natas24.natas.labs.overthewire.orgCredentials: natas24:0xzF30T9Av8lgXhW7slhFCIsVKAPyl2rCode&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;h1&gt;natas24&lt;/h1&gt;&lt;div id=\"content\"&gt;Password:&lt;form name=\"input\" method=\"get\"&gt;    &lt;input type=\"text\" name=\"passwd\" size=20&gt;    &lt;input type=\"submit\" value=\"Login\"&gt;&lt;/form&gt;&lt;?php    if(array_key_exists(\"passwd\",$_REQUEST)){        if(!strcmp($_REQUEST[\"passwd\"],\"&lt;censored&gt;\")){            echo \"&lt;br&gt;The credentials for the next level are:&lt;br&gt;\";            echo \"&lt;pre&gt;Username: natas25 Password: &lt;censored&gt;&lt;/pre&gt;\";        }        else{            echo \"&lt;br&gt;Wrong!&lt;br&gt;\";        }    }?&gt;  &lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 24 also looked extremely simple. It had one condition where the password and the censored value had to be identical for next level’s credentials to be returned, this was done using the strcmp or string compare function. Upon returning true, the strcmp() would give a value of 0, and the ‘!’ Inverted it to a 1 (as it returns a true if the previous condition ie ‘not false’). This meant that in boolean, it would return a true so the program returned the password. Knowing this, I entered passwd[]= , resulting in an array being compared to the string, returning a null, which was represented as 0 so it returned the password.FixThe solution for this would be to update php to the latest version, as the latest version no longer returns a null value, it only has an error. Alternatively, the function ’strncmp’ may be used which is not subject to this vulnerability, providing a quick fix.Password: O9QD9DZBDq1YpswiTM5oqMDaOtuZtAcxLevel 25URL: http://natas25.natas.labs.overthewire.orgCredentials: natas25:O9QD9DZBDq1YpswiTM5oqMDaOtuZtAcxCode&lt;html&gt;&lt;head&gt;&lt;body&gt;&lt;?php    function setLanguage(){        if(array_key_exists(\"lang\",$_REQUEST))            if(safeinclude(\"language/\" . $_REQUEST[\"lang\"] ))                return 1;        safeinclude(\"language/en\");     }        function safeinclude($filename){        // check for directory traversal        if(strstr($filename,\"../\")){            logRequest(\"Directory traversal attempt! fixing request.\");            $filename=str_replace(\"../\",\"\",$filename);        }        // dont let ppl steal our passwords        if(strstr($filename,\"natas_webpass\")){            logRequest(\"Illegal file access detected! Aborting!\");            exit(-1);        }        // add more checks...        if (file_exists($filename)) {             include($filename);            return 1;        }        return 0;    }        function listFiles($path){        $listoffiles=array();        if ($handle = opendir($path))            while (false !== ($file = readdir($handle)))                if ($file != \".\" &amp;&amp; $file != \"..\")                    $listoffiles[]=$file;                closedir($handle);        return $listoffiles;    }         function logRequest($message){        $log=\"[\". date(\"d.m.Y H::i:s\",time()) .\"]\";        $log=$log . \" \" . $_SERVER['HTTP_USER_AGENT'];        $log=$log . \" \\\"\" . $message .\"\\\"\\n\";         $fd=fopen(\"/var/www/natas/natas25/logs/natas25_\" . session_id() .\".log\",\"a\");        fwrite($fd,$log);        fclose($fd);    }?&gt;&lt;h1&gt;natas25&lt;/h1&gt;&lt;div id=\"content\"&gt;&lt;div align=\"right\"&gt;&lt;form&gt;&lt;select name='lang' onchange='this.form.submit()'&gt;&lt;option&gt;language&lt;/option&gt;&lt;?php foreach(listFiles(\"language/\") as $f) echo \"&lt;option&gt;$f&lt;/option&gt;\"; ?&gt;&lt;/select&gt;&lt;/form&gt;&lt;/div&gt;&lt;?php      session_start();    setLanguage();        echo \"&lt;h2&gt;$__GREETING&lt;/h2&gt;\";    echo \"&lt;p align=\\\"justify\\\"&gt;$__MSG\";    echo \"&lt;div align=\\\"right\\\"&gt;&lt;h6&gt;$__FOOTER&lt;/h6&gt;&lt;div&gt;\";?&gt;&lt;p&gt;&lt;div id=\"viewsource\"&gt;&lt;a href=\"index-source.html\"&gt;View sourcecode&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;SolutionLevel 25 consisted of a quote and a dropdown menu. The source code hinted towards the usage of a directory traversal attack to retrieve information. The program had a filter that removed ‘../‘ from a string, however since this wasn’t recursive and failed to account for url encoded bypasses, it was easy to bypass and I was able to retrieve the session logs by adding /?lang=….//….//logs/natas25[cookie].log. {Note: the program saved the logs as natas25[cookie].log in /var/www/natas/natas25/logs/}. After inspecting the response in burp, I noticed that the log would print anything in the user-agent header, therefore I decided to manipulate it to run php code which would return the contents of /etc/natas_webpass/natas26 to retrieve the password. This was done with the file_get_contents function, which returned the contents of the file. With (replace %3F with ?), I was able to find the password to level 25.FixThe solution to directory traversal would be to account for all url encoding methods and have a recursive loop that removes all of the illegal content within the url request until it is clean, which prevents directory traversal. Additionally, the developer may completely disable user input to the filesystem API which would completely prevent all vulnerabilities.Password: 8A506rfIAXbKKk68yJeuTuRq4UfcK70k"
  }
  
]

